import datetime
import os
from mech_core.standards.units import ureg

class ReportGenerator:
    """
    Centralized documentation engine.
    Collects analysis objects and formats them into a single Engineering Report.
    """
    def __init__(self, project_name: str, author: str, version: str = "1.0"):
        self.title = project_name
        self.author = author
        self.date = datetime.datetime.now().strftime("%Y-%m-%d")
        self.version = version
        self.elements = [] # List of strings or blocks

    def add_header(self):
        """Adds the standard cover page/header details"""
        self.elements.append(f"# {self.title}")
        self.elements.append(f"**Author:** {self.author} | **Date:** {self.date} | **Ver:** {self.version}")
        self.elements.append("---")
    
    def add_section(self, title: str):
        self.elements.append(f"## {title}")

    def add_text(self, text: str):
        self.elements.append(text)

    def add_image(self, caption: str, path: str):
        """
        Adds an image to the report with caption.

        Args:
            caption: Image caption text
            path: Path to the image file
        """
        image_md = f"![{caption}]({path})\n*{caption}*"
        self.elements.append(image_md)

    def add_calculation_result(self, title: str, data_dict: dict, status: str = None):
        """
        Formats a dictionary (like from beams.py/columns.py) into a readable block.
        """
        md = []
        md.append(f"### {title}")
        
        # Color code the status if provided
        if status:
            icon = "✅" if status == "PASS" else "❌"
            md.append(f"> **Status:** {icon} {status}")
            
        md.append("| Parameter | Value | Unit |")
        md.append("| :--- | :--- | :--- |")
        
        for k, v in data_dict.items():
            # Skip internal keys if needed
            if k in ["status", "axis", "calc_trace", "ltb_zone"]: continue
            
            # Format Pint Quantities
            if hasattr(v, "magnitude"):
                # {:~P} uses short units (mm) and pretty formatting
                val_str = f"{v.magnitude:.2f}"
                unit_str = f"{v.units:~P}"
            elif isinstance(v, float):
                val_str = f"{v:.2f}"
                unit_str = "-"
            else:
                val_str = str(v)
                unit_str = "-"
                
            md.append(f"| {k} | {val_str} | {unit_str} |")
            
        self.elements.append("\n".join(md))

    def add_module(self, analysis_object):
        """
        Accepts a Class instance (like BasePlateDesign) that has a 
        .generate_markdown() method.
        """
        if hasattr(analysis_object, "generate_markdown"):
            self.elements.append(analysis_object.generate_markdown())
        else:
            self.elements.append(f"> **Error:** Object {type(analysis_object)} has no report method.")

    def save(self, filename: str):
        """Compiles and saves the markdown file."""
        # Add a footer
        self.elements.append("\n---\n*Generated by MechanicalDesignTools*")
        
        full_text = "\n\n".join(self.elements)
        
        with open(filename, "w", encoding="utf-8") as f:
            f.write(full_text)
        
        print(f"Report saved to: {os.path.abspath(filename)}")

    def add_symbolic_derivation(self, title: str, steps: list):
        """
        Renders a calculation trace using the "Physics Exam" method.
        
        Args:
            steps: List of dicts with:
                   - 'desc': Step Title
                   - 'ref': (Optional) Design Code Reference
                   - 'variables': (Optional) List of strings ["m = 10 kg", "a = 5 m/s2"] for the top
                   - 'symbol': Governing Equation (F = ma)
                   - 'sub': Substitution (F = 10 * 5)
                   - 'result': Final Answer (50 N)
                   - 'conclusion': The "Therefore" statement.
        """
        self.elements.append(f"### {title}")
        
        for step in steps:
            # 1. Description (Header)
            header = f"**{step['desc']}**"
            if 'ref' in step:
                header += f" *[{step['ref']}]*"
            self.elements.append(header)
            
            # 2. Math Block
            lines = []
            lines.append("$$")
            
            # A. Variable Declaration (Used in Step 1)
            if 'variables' in step:
                lines.append(r"\begin{aligned}")
                # Group into pairs for compact display
                vars_list = step['variables']
                for i in range(0, len(vars_list), 2):
                    v1 = vars_list[i]
                    v2 = vars_list[i+1] if i+1 < len(vars_list) else ""
                    # LaTeX alignment magic
                    lines.append(f"{v1} & \\quad {v2} \\\\")
                lines.append(r"\end{aligned}")
            
            # B. The Calculation (Equation -> Sub -> Result)
            else:
                if 'symbol' in step:
                    lines.append(step['symbol'] + r" \\")
                if 'sub' in step:
                    lines.append(step['sub'] + r" \\")
                if 'result' in step:
                    lines.append(r"\rightarrow \mathbf{" + step['result'] + "}")
            
            lines.append("$$")
            self.elements.append("\n".join(lines))
            
            # 3. The "Therefore" Conclusion
            if 'conclusion' in step:
                self.elements.append(f"> *{step['conclusion']}*\n")
            else:
                self.elements.append("") # Spacing